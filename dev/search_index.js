var documenterSearchIndex = {"docs":
[{"location":"apis/","page":"API documentation","title":"API documentation","text":"CurrentModule = CitableBase","category":"page"},{"location":"apis/#API-documentation","page":"API documentation","title":"API documentation","text":"","category":"section"},{"location":"apis/#URNs","page":"API documentation","title":"URNs","text":"","category":"section"},{"location":"apis/","page":"API documentation","title":"API documentation","text":"Urn\ncomponents\nparts\naddversion\ndropversion","category":"page"},{"location":"apis/#CitableBase.Urn","page":"API documentation","title":"CitableBase.Urn","text":"Unique identifiers expressible in the syntax of the IETF's URN specification.\n\n\n\n\n\n","category":"type"},{"location":"apis/#CitableBase.components","page":"API documentation","title":"CitableBase.components","text":"components(uString)\n\n\nSplits a string on colons (separator for top-level components of URNs).\n\nExamples\n\njulia> components(\"urn:cts:greekLit:tlg0012.tlg001.msA:1.1\")\n\n\n\n\n\ncomponents(u)\n\n\nSplits a URN's string representation into top-level components.\n\n\n\n\n\n","category":"function"},{"location":"apis/#CitableBase.parts","page":"API documentation","title":"CitableBase.parts","text":"parts(componentString)\n\n\nSplits a string on periods (seprator for parts within components of URNs).\n\nExamples\n\njulia> parts(\"tlg0012.tlg001.msA\")\n\n\n\n\n\n","category":"function"},{"location":"apis/#CitableBase.addversion","page":"API documentation","title":"CitableBase.addversion","text":"Urn subtypes should implement addversion(urn::U, versionid)::U.  \n\naddversion(u, versioninfo)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/#CitableBase.dropversion","page":"API documentation","title":"CitableBase.dropversion","text":"Urn subtypes should implement dropversion(urn::U)::U.\n\ndropversion(u)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/#Citable-resources","page":"API documentation","title":"Citable resources","text":"","category":"section"},{"location":"apis/","page":"API documentation","title":"API documentation","text":"Citable\nCitableTrait\nNotCitable\ncitabletrait\ncitable\nurn\nlabel","category":"page"},{"location":"apis/#CitableBase.Citable","page":"API documentation","title":"CitableBase.Citable","text":"A citable unit of any kind is identified by a URN and has a human-readable label.\n\n\n\n\n\n","category":"type"},{"location":"apis/#CitableBase.CitableTrait","page":"API documentation","title":"CitableBase.CitableTrait","text":"Abstraction of values for a citable trait.\n\n\n\n\n\n","category":"type"},{"location":"apis/#CitableBase.NotCitable","page":"API documentation","title":"CitableBase.NotCitable","text":"Value for the CitableTrait for everything not citable.\n\n\n\n\n\n","category":"type"},{"location":"apis/#CitableBase.citabletrait","page":"API documentation","title":"CitableBase.citabletrait","text":"Define default value of CitableTrait as NotCitable.\n\n\n\n\n\n","category":"function"},{"location":"apis/#CitableBase.citable","page":"API documentation","title":"CitableBase.citable","text":"True if x is a citable object.\n\n\n\n\n\n","category":"function"},{"location":"apis/#CitableBase.urn","page":"API documentation","title":"CitableBase.urn","text":"Delegate urn to specific functions based on  type's citable trait value.\n\nurn(x)\n\n\n\n\n\n\nIt is an error to invoke the urn function on material that is not citable.\n\nurn(_, x)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/#CitableBase.label","page":"API documentation","title":"CitableBase.label","text":"Delegate label to specific functions based on  type's citable trait value.\n\n\n\n\n\nIt is an error to invoke the label function on material that is not citable.\n\nlabel(_, x)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/#URN-comparison","page":"API documentation","title":"URN comparison","text":"","category":"section"},{"location":"apis/","page":"API documentation","title":"API documentation","text":"UrnComparisonTrait\nNotUrnComparable\nurncomparisontrait\nurncomparable\nurnequals\nurncontains\nurnsimilar","category":"page"},{"location":"apis/#CitableBase.UrnComparisonTrait","page":"API documentation","title":"CitableBase.UrnComparisonTrait","text":"Abstraction of values for URN manipulation.\n\n\n\n\n\n","category":"type"},{"location":"apis/#CitableBase.NotUrnComparable","page":"API documentation","title":"CitableBase.NotUrnComparable","text":"Value of the UrnComparisonTrait for evertything that can NOT be compared using URN logic.\n\n\n\n\n\n","category":"type"},{"location":"apis/#CitableBase.urncomparisontrait","page":"API documentation","title":"CitableBase.urncomparisontrait","text":"Default value of UrnComparisonTrait is NotUrnComparable.\n\n\n\n\n\n","category":"function"},{"location":"apis/#CitableBase.urncomparable","page":"API documentation","title":"CitableBase.urncomparable","text":"True if type T implements the UrnComparisonTrait.\n\n\n\n\n\n","category":"function"},{"location":"apis/#CitableBase.urnequals","page":"API documentation","title":"CitableBase.urnequals","text":"For subtypes of Urn, implement urnequals concretely.\n\nurnequals(u1, u2)\n\n\n\n\n\n\nURN-comparable objects must implement urnequals.\n\nurnequals(x, y)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/#CitableBase.urncontains","page":"API documentation","title":"CitableBase.urncontains","text":"URN-comparable objects must implement urncontains.\n\n\n\n\n\n","category":"function"},{"location":"apis/#CitableBase.urnsimilar","page":"API documentation","title":"CitableBase.urnsimilar","text":"URN-comparable objects must implement urnsimilar.\n\n\n\n\n\n","category":"function"},{"location":"apis/#CEX-serialization","page":"API documentation","title":"CEX serialization","text":"","category":"section"},{"location":"apis/","page":"API documentation","title":"API documentation","text":"CexTrait\nNotCexSerializable\ncextrait\ncexserializable\ncex\nfromcex","category":"page"},{"location":"apis/#CitableBase.CexTrait","page":"API documentation","title":"CitableBase.CexTrait","text":"Trait for objects serializable in CEX format.\n\n\n\n\n\n","category":"type"},{"location":"apis/#CitableBase.NotCexSerializable","page":"API documentation","title":"CitableBase.NotCexSerializable","text":"Value for the CexTrait for content not serializable to CEX format.\n\n\n\n\n\n","category":"type"},{"location":"apis/#CitableBase.cextrait","page":"API documentation","title":"CitableBase.cextrait","text":"The default value of CexTrait is NotCexSerializable.\n\ncextrait(_)\n\n\n\n\n\n\nSubtypes of Citable are CexSerializable.\n\ncextrait(_)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/#CitableBase.cexserializable","page":"API documentation","title":"CitableBase.cexserializable","text":"True if type T is serializable to CEX format\n\n\n\n\n\n","category":"function"},{"location":"apis/#CitableBase.cex","page":"API documentation","title":"CitableBase.cex","text":"Delegate cex to specific functions based on  type's cextrait value.\n\n\n\n\n\nIt is an error to invoke the cex function on material that is not CEX serializable.\n\ncex(, x; delimiter)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/#CitableBase.fromcex","page":"API documentation","title":"CitableBase.fromcex","text":"Dispatch fromcex on cextrait of T to instantiate an object of type T from CEX-formatted data cexsrc.\n\nfromcex(cexsrc, T; delimiter, configuration, strict)\n\n\n\n\n\n\nImplement fromcex using first string parameter for a file name.\n\nfromcex(fname, T, freader; delimiter, configuration, strict)\n\n\n\n\n\n\nImplement fromcex using first string parameter for a URL.\n\nfromcex(url, T, ureader; delimiter, configuration, strict)\n\n\n\n\n\n\nImplement fromcex using first string parameter for raw string data.\n\nfromcex(cexsrc, T, freader; delimiter, configuration, strict)\n\n\n\n\n\n\nIt is an error to invoke the fromcex function on material that is not CEX serializable.\n\nfromcex(, cex, T; delimiter, configuration, strict)\n\n\n\n\n\n\nIt is an error invoke fromcex function with an unimplemented trait value.\n\nfromcex(traitvalue, cexsrc, T; delimiter, configuration, strict)\n\n\n\n\n\n\n","category":"function"},{"location":"apis/#Citable-collections","page":"API documentation","title":"Citable collections","text":"","category":"section"},{"location":"apis/","page":"API documentation","title":"API documentation","text":"CitableCollectionTrait\nNotCitableCollection\ncitablecollectiontrait\ncitablecollection","category":"page"},{"location":"apis/#CitableBase.CitableCollectionTrait","page":"API documentation","title":"CitableBase.CitableCollectionTrait","text":"Abstraction of values for a citable library collection trait.\n\n\n\n\n\n","category":"type"},{"location":"apis/#CitableBase.NotCitableCollection","page":"API documentation","title":"CitableBase.NotCitableCollection","text":"Value for the CitableCollectionTrait for evertything that is not a citable library collection.\n\n\n\n\n\n","category":"type"},{"location":"apis/#CitableBase.citablecollectiontrait","page":"API documentation","title":"CitableBase.citablecollectiontrait","text":"Define default value of CitableCollectionTrait as NotCitableCollection.\n\n\n\n\n\n","category":"function"},{"location":"apis/#CitableBase.citablecollection","page":"API documentation","title":"CitableBase.citablecollection","text":"True if x has the value CitableCollection for the CitableCollectionTrait.\n\n\n\n\n\n","category":"function"},{"location":"urns/#Identification-with-URNs","page":"Identifiers","title":"Identification with URNs","text":"","category":"section"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"SummaryThe task: ISBN numbers uniquely identify published editions of a book.  We want to create a type representing a 10-digit ISBN number, and be able to compare ISBN numbers using URN logic.The implementation:define a new URN type representing an ISBN-10 number\nimplement the UrnComparisonTrait for the new type","category":"page"},{"location":"urns/#Defining-the-Isbn10Urn-type","page":"Identifiers","title":"Defining the Isbn10Urn type","text":"","category":"section"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"The Urn abstract type models a Uniform Resource Name (URN). We'll follow  the requirements of the URN standard to create a URN type for ISBN-10 numbers.  Its URN strings will have three colon-delimited components, beginning with the required prefix urn, then a URN type we'll call isbn10, followed by a 10-digit ISBN number.  For example, the URN for Distant Horizons by Ted Underwood will be urn:isbn10:022661283X. (Yes, the last \"digit\" of an ISBN number can be X.)","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"We will make the new type a subtype of Urn, so that we can use it freely with other packages that recognize URNs.","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"using CitableBase\nstruct Isbn10Urn <: Urn\n    isbn::AbstractString\nend","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"warning: Note on the ISBN format and our `Isbn10Urn` type\nThere is in fact a URN namespace for ISBN numbers identifeid by the isbn namespace identifier. (See this blogpost about citing publications with URNs.)  This guide invents an isbn10 URN type solely to illustrate how you could create your own URN type using the CitableBase package.Parsing the full ISBN-10 format is extremely complicated: ISBN-10 numbers have four components, each of which is variable in length! In this user's guide example, we'll restrict ourselves to ISBNs for books published in English-, French- or German-speaking countries, indicated by an initial digit of 0 or 1 (English), 2 (French) or 3 (German).  In a real program, we would enforce this in the constructor, but to keep our example brief and focused on the CitableBase class, we blindly accept any string value for the isbn field of our type.","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"Our new type is a subtype of Urn.","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"supertype(Isbn10Urn)","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"As often in Julia, we'll override the default show method for our type.  (Note that in Julia this requires importing the specific method, not just using the package.)","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"import Base: show\nfunction show(io::IO, u::Isbn10Urn)\n    print(io, u.isbn)\nend","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"Now when we create objects of our new type, the display in our REPL (or other contexts) will be easily recognizable as an Isbn10Urn.","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"distanthorizons = Isbn10Urn(\"urn:isbn10:022661283X\")","category":"page"},{"location":"urns/#Defining-the-UrnComparisonTrait","page":"Identifiers","title":"Defining the UrnComparisonTrait","text":"","category":"section"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"Subtypes of Urn are required to implement the UrnComparisonTrait, and its three functions. CitableBase uses the \"Holy trait trick\" to dispatch functions implementing URN comparison. ","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"tip: The Tim Holy Trait Trick\nSee this post on julia bloggers for an introduction to the \"Tim Holy Trait Trick\" (THTT). .","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"We first define a subtype of the abstract UrnComparisonTrait.  It's a singleton type with no fields which we'll use as the trait value for our ISBN type.  CitableBase provides the urncomparisontrait function to determine if a class implements the UrnComparisonTrait so we'll import urncomparisontrait, and define a function returning a concrete value of IsbnComparable() for the type Isbn10Urn.","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"struct IsbnComparable <: UrnComparisonTrait end\n\nimport CitableBase: urncomparisontrait\nfunction urncomparisontrait(::Type{Isbn10Urn}) \n    IsbnComparable()\nend","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"Let's test it.","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"urncomparisontrait(typeof(distanthorizons))","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"This lets us use CitableBases boolean function urncomparable to test specific objects.","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"urncomparable(distanthorizons)","category":"page"},{"location":"urns/#Implementing-the-logic-of-URN-comparison","page":"Identifiers","title":"Implementing the logic of URN comparison","text":"","category":"section"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"To fulfill the contract of the UrnComparisonTrait, we must implement three boolean functions for three kinds of URN comparison: urnequals (for equality), urncontains (for containment) and and urnsimilar (for similarity).  Because we have defined our type as implementing the UrnComparisonTrait, CitableBase can dispatch to functions including an Isbn10Urn as the first parameter.","category":"page"},{"location":"urns/#Equality","page":"Identifiers","title":"Equality","text":"","category":"section"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"The == function of Julia Base is overridden in CitableBase for all subtypes of Urn.  This makes it trivial to implement urnequals once we use CitableBase and import urnequals.","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"import CitableBase: urnequals\nfunction urnequals(u1::Isbn10Urn, u2::Isbn10Urn)\n    u1 == u2\nend","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"dupe = distanthorizons\nurnequals(distanthorizons, dupe)","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"enumerations = Isbn10Urn(\"urn:isbn10:022656875X\")\nurnequals(distanthorizons, enumerations)","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"tip: Why do we need 'urnequals' when we already have '==' ?\nOur implementation of urnequals uses two parameters of the same type to compare two URNs and produce a boolean result.  In the following section, we will implement the functions of UrnComparisonTrait with one URN parameter and one parameter giving a citable collection.  In those implementations, we can filter the collection by comparing the URN parameter to the URNs of items in the collection.  We will reserve == for comparing the contents of two collections, and use urnequals to filter a collection's content.","category":"page"},{"location":"urns/#Containment","page":"Identifiers","title":"Containment","text":"","category":"section"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"For our ISBN type, we'll define \"containment\" as true when two ISBNS belong to the same initial-digit group (0 - 4).  We'll use the components functions from CitableBase to extract the third part of each URN string, and compare their first characters.","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"import CitableBase: urncontains\nfunction urncontains(u1::Isbn10Urn, u2::Isbn10Urn)\n    initial1 = components(u1.isbn)[3][1]\n    initial2 = components(u2.isbn)[3][1]\n\n    initial1 == initial2\nend","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"Both Distant Horizons and Enumerations are in ISBN group 0.","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"urncontains(distanthorizons, enumerations)","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"But Can We Be Wrong? is in ISBN group 1.","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"wrong = Isbn10Urn(\"urn:isbn10:1108922036\")\nurncontains(distanthorizons, wrong)","category":"page"},{"location":"urns/#Similarity","page":"Identifiers","title":"Similarity","text":"","category":"section"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"We'll define \"similarity\" as belonging to the same language area.  In this definition, both 0 and 1 indicate English-language countries.","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"# True if ISBN starts with `0` or `1`\nfunction english(urn::Isbn10Urn)\n    langarea = components(urn.isbn)[3][1]\n    langarea == '0' || langarea == '1'\nend\n\nimport CitableBase: urnsimilar\nfunction urnsimilar(u1::Isbn10Urn, u2::Isbn10Urn)\n    initial1 = components(u1.isbn)[3][1]\n    initial2 = components(u2.isbn)[3][1]\n\n    (english(u1) && english(u2)) ||  initial1 == initial2\nend","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"Both Distant Horizons and Can We Be Wrong? are published in English-language areas.","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"urnsimilar(distanthorizons, wrong)","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"But they are coded for different ISBN areas.","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"wrong = Isbn10Urn(\"urn:isbn10:1108922036\")\nurncontains(distanthorizons, wrong)","category":"page"},{"location":"urns/#Optional-methods","page":"Identifiers","title":"Optional methods","text":"","category":"section"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"The CtsUrn (from CitableText) and the Cite2Urn (from CitableObject) illustrate two optional behaviors: support for versioning of URNs, and support for subreferences.  Although our ISBN numbers don't require either of those features, we'll illustrate how they are implemented.","category":"page"},{"location":"urns/#Versioning","page":"Identifiers","title":"Versioning","text":"","category":"section"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"The three relevant functions are supportsversion, addversion and dropversion.  We'll indicate that our URN type supports versioning but for this demonstration will just pass the URN through unchanged.","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"import CitableBase: supportsversion\nfunction supportsversion(u::Isbn10Urn)\n    true\nend\n\nimport CitableBase: addversion\nfunction addversion(u::Isbn10Urn, versioninfo::AbstractString)\n    u\nend\n\nimport CitableBase: dropversion\nfunction dropversion(u::Isbn10Urn)\n    u\nend","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"supportsversion(wrong)","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"addversion(wrong, \"v2\")","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"dropversion(wrong)","category":"page"},{"location":"urns/#Subreferences","page":"Identifiers","title":"Subreferences","text":"","category":"section"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"import CitableBase: supportssubref\nfunction supportssubref(u::Isbn10Urn)\n    true\nend\n\nimport CitableBase: dropsubref\nfunction dropsubref(u::Isbn10Urn)\n    u\nend\n\nimport CitableBase: hassubref\nfunction hassubref(u::Isbn10Urn)\n    false\nend\n\nimport CitableBase: subref\nfunction subref(u::Isbn10Urn)\n    nothing\nend","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"supportssubref(wrong)","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"hassubref(wrong)","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"dropsubref(wrong)","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"subref(wrong)","category":"page"},{"location":"urns/#Recap:-identifiers","page":"Identifiers","title":"Recap: identifiers","text":"","category":"section"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"On this page, we defined the Isnb10Urn type as a subtype of Urn and identified our type as implementing the UrnComparisonTrait.  You can test this with urncomparables.","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"urncomparable(distanthorizons)","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"We implemented the trait's required functions to compare pairs of URNs based on URN logic for equality, similarity and containment, and return boolean values.","category":"page"},{"location":"urns/","page":"Identifiers","title":"Identifiers","text":"The next page will make use of our URN type to define a citable object identified by Isbn10Urn.","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"#page 1\nusing CitableBase\nstruct Isbn10Urn <: Urn\n    isbn::AbstractString\nend\n\nimport Base: show\nfunction show(io::IO, u::Isbn10Urn)\n    print(io, u.isbn)\nend\n\nstruct IsbnComparable <: UrnComparisonTrait end\nimport CitableBase: urncomparisontrait\nfunction urncomparisontrait(::Type{Isbn10Urn})\n    IsbnComparable()\nend\n\nimport CitableBase: urnequals\nfunction urnequals(u1::Isbn10Urn, u2::Isbn10Urn)\n    u1 == u2\nend\n\nimport CitableBase: urncontains\nfunction urncontains(u1::Isbn10Urn, u2::Isbn10Urn)\n    initial1 = components(u1.isbn)[3][1]\n    initial2 = components(u2.isbn)[3][1]\n    initial1 == initial2\nend\n\nfunction english(urn::Isbn10Urn)\n    langarea = components(urn.isbn)[3][1]\n    langarea == '0' || langarea == '1'\nend\n\nimport CitableBase: urnsimilar\nfunction urnsimilar(u1::Isbn10Urn, u2::Isbn10Urn)\n    initial1 = components(u1.isbn)[3][1]\n    initial2 = components(u2.isbn)[3][1]\n\n    (english(u1) && english(u2)) ||  initial1 == initial2\nend\n\n\n\ndistanthorizons = Isbn10Urn(\"urn:isbn10:022661283X\")\nenumerations = Isbn10Urn(\"urn:isbn10:022656875X\")\nwrong = Isbn10Urn(\"urn:isbn10:1108922036\")\n\n#page2\nabstract type CitablePublication end\nstruct CitableBook <: CitablePublication\n    urn::Isbn10Urn\n    title::AbstractString\n    authors::AbstractString\nend\n\nfunction show(io::IO, book::CitableBook)\n    print(io, book.authors, \", *\", book.title, \"* (\", book.urn, \")\")\nend\n\nimport Base.==\nfunction ==(book1::CitableBook, book2::CitableBook)\n    book1.urn == book2.urn && book1.title == book2.title && book1.authors == book2.authors\nend\n\nstruct CitableByIsbn10 <: CitableTrait end\nimport CitableBase: citabletrait\nfunction citabletrait(::Type{CitableBook})\n    CitableByIsbn10()\nend\n\nimport CitableBase: urn\nfunction urn(book::CitableBook)\n    book.urn\nend\n\nimport CitableBase: label\nfunction label(book::CitableBook)\n    string(book)\nend\n\n\nstruct BookComparable <: UrnComparisonTrait end\nfunction urncomparisontrait(::Type{CitableBook})\n    BookComparable()\nend\n\nfunction urnequals(bk1::CitableBook, bk2::CitableBook)\n    bk1.urn == bk2.urn\nend\nfunction urncontains(bk1::CitableBook, bk2::CitableBook)\n    urncontains(bk1.urn, bk2.urn)\nend\nfunction urnsimilar(bk1::CitableBook, bk2::CitableBook)\n    urnsimilar(bk1.urn, bk2.urn)\nend\n\nstruct BookCex <: CexTrait end\nimport CitableBase: cextrait\nfunction cextrait(::Type{CitableBook})\n    BookCex()\nend\n\nimport CitableBase: cex\n\"Implement for CitableBook\"\nfunction cex(book::CitableBook; delimiter = \"|\")\n    join([string(book.urn), book.title, book.authors], delimiter)\nend\n\nimport CitableBase: fromcex\nfunction fromcex(traitvalue::BookCex, cexsrc::AbstractString, T;\n    delimiter = \"|\", configuration = nothing, strict = true)\n    fields = split(cexsrc, delimiter)\n    urn = Isbn10Urn(fields[1])\n    CitableBook(urn, fields[2], fields[3])\nend\n\n\nqi = Isbn10Urn(\"urn:isbn10:3030234133\")\n\ndistantbook = CitableBook(distanthorizons, \"Distant Horizons: Digital Evidence and Literary Change\", \"Ted Underwood\")\nenumerationsbook = CitableBook(enumerations, \"Enumerations: Data and Literary Study\", \"Andrew Piper\")\nwrongbook = CitableBook(wrong, \"Can We Be Wrong? The Problem of Textual Evidence in a Time of Data\", \"Andrew Piper\")\nqibook = CitableBook(qi, \"Quantitative Intertextuality: Analyzing the Markers of Information Reuse\",\"Christopher W. Forstall and Walter J. Scheirer\")\n\n\n# root of repository in file system:\nroot = pwd() |> dirname |> dirname","category":"page"},{"location":"collections/#Citable-collections","page":"Citable collections","title":"Citable collections","text":"","category":"section"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"SummaryThe task: We want to create a type for working with a collection of the citable books we developed on the previous page.   We should be able to filter the collection by appying URN logic to the identifiers for our books.  We should be able to write our collection to plain-text format and re-instantiate it from the plain-text representation.  And we should be able to apply any Julia functions for working with iterable content to our book list.The implementation:define a new type for a collection of citable books, the ReadingList type\nidentify it as a citable collection (the CitableCollectionTrait)\nimplement filtering the collection using URN logic (the UrnComparisonTrait)\nimplement round-trip serialization (the CexTrait)\nmake the collection available to all Julia functions working with iterable content (Iterators)","category":"page"},{"location":"collections/#Defining-the-ReadingList","page":"Citable collections","title":"Defining the ReadingList","text":"","category":"section"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"Our model for a reading list is simple: it's just a Vector of citable publications.  We'll annotate our vector as containing subtypes of the abstract CitablePublication we previously defined, even though in this example we'll only use our one concrete implementation, the CitableBook.  As with our other custom types, we'll override Base.show.","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"struct ReadingList\n    publications::Vector{<: CitablePublication}\nend","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"function show(io::IO, readingList::ReadingList)\n    print(io, \"ReadingList with \", length(readingList.publications), \" items\")\nend","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"Let's see an example.","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"books = [distantbook, enumerationsbook, wrongbook, qibook]\nrl = ReadingList(books)","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"The publications field is just a normal Julia Vector.","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"rl.publications[4]","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"What will make it different from other Vectors is that it will support a series of CITE traits","category":"page"},{"location":"collections/#Implementing-the-CitableCollectionTrait","page":"Citable collections","title":"Implementing the CitableCollectionTrait","text":"","category":"section"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"We first want to identify our new type as fufilling the requirements of a citable collection with the CitableCollectionTrait. We'll repeat the pattern:","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"define a singleton type for the trait value.\noverride the function identifying the trait value for our new type.  Here the function is named citablecollectiontrait, and we'll define it to return the concrete value CitableReadingList for the tyupe ReadingList.","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"struct CitableReadingList <: CitableCollectionTrait end\n\nimport CitableBase: citablecollectiontrait\nfunction citablecollectiontrait(::Type{ReadingList}) \n    CitableReadingList()\nend","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"citablecollectiontrait(typeof(rl))","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"Use the citablecollection function to test if a specific object is a citable collection.","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"citablecollection(rl)","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"Like citable objects, citable collections should report the type of URN they use for citation.","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"import CitableBase: urntype\nfunction urntype(readingList::ReadingList)\n    Isbn10Urn\nend","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"urntype(rl)","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"The promise we now need to fulfill is that our collection will implement three further traits for URN comparison, serialization and iteration.","category":"page"},{"location":"collections/#Implementing-the-UrnComparisonTrait","page":"Citable collections","title":"Implementing the UrnComparisonTrait","text":"","category":"section"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"We have previously implemented the UrnComparisonTrait for an identifer type (the Isbn10Urn) and for a citable object type (the CitableBook).  In both of those cases, we compared two objects of the same type, and returned a boolean result of comparing them on URN logic.  ","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"For our citable collection, we will implement the same suite of functions, but with a different signature and result type.  This time, our first parameter will be a URN which we will use to filter the collection given in the second parameter.  The result will be a (possibly empty) list of content in our citable collection – in this example, a list of CitableBooks.","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"We mark our ReadingList type as urn-comparable exactly as we did for Isbn10Urns and CitableBooks.","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"struct ReadingListComparable <: UrnComparisonTrait end\nfunction urncomparisontrait(::Type{ReadingList}) \n    ReadingListComparable()\nend","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"urncomparable(rl)","category":"page"},{"location":"collections/#Implementing-the-required-functions-urnequals,-urncontains-and-urnsimilar","page":"Citable collections","title":"Implementing the required functions urnequals, urncontains and urnsimilar","text":"","category":"section"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"To implement the required functions, we'll just lean on the work we've already done: we'll use the boolean version of those functions to filter our collections.","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"function urnequals(urn::Isbn10Urn, reading::ReadingList, )\n    filter(item -> urnequals(item.urn, urn), reading.publications)\nend\n\nfunction urncontains(urn::Isbn10Urn, reading::ReadingList)\n    filter(item -> urncontains(item.urn, urn), reading.publications)\nend\n\nfunction urnsimilar(urn::Isbn10Urn, reading::ReadingList)\n    filter(item -> urnsimilar(item.urn, urn), reading.publications)\nend","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"If your collection does not allow duplicate identifiers, urnequals should return a list of 0 or 1 item.","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"urnequals(distanthorizons, rl)","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"Three of the books in our list are published in the English-language zone, and therefore will satisfy urnsimilar when compared to Distant Horizons.","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"urnsimilar(distanthorizons, rl)","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"But only two are published in the same ISBN area code as Distant Horizons:","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"urncontains(distanthorizons, rl)","category":"page"},{"location":"collections/#Implementing-the-CexTrait","page":"Citable collections","title":"Implementing the CexTrait","text":"","category":"section"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"As we did with citable objects, we want to ensure that we can round-trip an entire collection to and from delimited-text format.  We'll make our new ReadingList type implement CexTrait in the same way as CitableBook.","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"struct ReadingListCex <: CexTrait end\nfunction cextrait(::Type{ReadingList})\n    ReadingListCex()\nend","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"cexserializable(rl)","category":"page"},{"location":"collections/#Implementing-the-required-functions-cex-and-fromcex","page":"Citable collections","title":"Implementing the required functions cex and fromcex","text":"","category":"section"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"We will serialize our collection with a header line identifying it as citecollection block, followed by one line for each book in our list.  We can format the books' data by mapping each book to an invocation the cex that we previously wrote for CitableBooks.","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"function cex(reading::ReadingList; delimiter = \"|\")\n    header = \"#!citecollection\\n\"\n    strings = map(ref -> cex(ref, delimiter=delimiter), reading.publications)\n    header * join(strings, \"\\n\")\nend","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"cexoutput = cex(rl)\nprintln(cexoutput)","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"Recall from our experience implementing CEX serialization for CitableBooks that we will need to expose three mandatory parameters for fromcex: the trait value, the CEX data and the Julia type we want to instantiate.","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"function fromcex(trait::ReadingListCex, cexsrc::AbstractString, T; \n    delimiter = \"|\", configuration = nothing, strict = true)\n    \n    lines = split(cexsrc, \"\\n\")\n    datalines = filter(ln -> !isempty(ln), lines)\n    isbns = CitableBook[]\n    inblock = false\n    for ln in datalines\n        if ln == \"#!citecollection\"\n            inblock = true\n        elseif inblock\n            bk = fromcex(ln, CitableBook)\n            push!(isbns, bk)\n        end\n    end\n    ReadingList(isbns)\nend","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"warning: Warning\nTo keep this example brief and avoid introducing other packages, our implementation of fromcex naively assumes cexsrc will contain a single CEX block introduced by the #!citecollection heading.  This would break on real world CEX data sources: in a real application, we would instead use the CiteEXchange package to parse and extract appropriate blocks.  See the documentation of CiteEXchange, or look at how a package like CitableCorpus uses CiteEXchange in its implementation of fromcex for different data type.","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"Once again, we can now invoke fromcex with just the parameters for the CEX data and desired Julia type to create, and CitableBase will find our implementation.","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"fromcex(cexoutput, ReadingList)","category":"page"},{"location":"collections/#Free-bonus!","page":"Citable collections","title":"Free bonus!","text":"","category":"section"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"CitableBase optionally allows you to include a third parameter to the fromcex function naming the type of reader to apply to the first string parameter.  Valid values are StringReader, FileReader or UrlReader.  The previous example relied on the default value of StringReader.  The following examples use the file RL/test/data/dataset.cex  in this repository; its contents are the output of cex(rl) above.","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"fname = joinpath(root, \"RL\", \"test\", \"data\", \"dataset.cex\")\nfileRL = fromcex(fname, ReadingList, FileReader)","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"url = \"https://raw.githubusercontent.com/cite-architecture/CitableBase.jl/dev/RL/test/data/dataset.cex\"\nurlRL = fromcex(url, ReadingList, UrlReader)","category":"page"},{"location":"collections/#Implementing-required-and-optional-frnctions-from-Base.Iterators","page":"Citable collections","title":"Implementing required and optional frnctions from Base.Iterators","text":"","category":"section"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"The Iterators module in Julia Base was one of the first traits or interfaces in Julia.  It allows you to apply the same functions to many types of iterable collections.  We need to import the Base.iterate function, and implement two versions of it for our new type: one with a single parameter for the collection, and one with a second parameter maintaining some kind of state information.  Both of them have the same return type: either nothing, or a Tuple pairing one item in the collection with state information.","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"Since our reading list is keeping books in a Vector internally, we can use the state parameter to pass along an index into the Vector.  In the version of iterate with no parameters, we'll return the first item in the list, and set the \"state\" value to 2.  In the two-parameter version, we'll return the item indexed by the state count, and bump the count up one.","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"import Base: iterate\n\nfunction iterate(rlist::ReadingList)\n    isempty(rlist.publications) ? nothing : (rlist.publications[1], 2)\nend\n\nfunction iterate(rlist::ReadingList, state)\n    state > length(rlist.publications) ? nothing : (rlist.publications[state], state + 1)\nend","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"It is also useful (and trivial) to implement the optional methods for the length and base type of the collection.","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"import Base: length\nfunction length(readingList::ReadingList)\n    length(readingList.publications)\nend\n\n\nimport Base: eltype\nfunction eltype(readingList::ReadingList)\n    CitablePublication\nend","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"length(rl)","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"eltype(rl)","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"Now our ReadingList type is usable with all the richness of the Julia interface for iterators.  Just a few examples:","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"for loops ","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"for item in rl\n    println(item)\nend","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"checking for presence of an item","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"distantbook in rl","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"collect contents without having to know anything about the internal structure of the type","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"collect(rl)","category":"page"},{"location":"collections/#More-free-stuff!","page":"Citable collections","title":"More free stuff!","text":"","category":"section"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"The slidingwindow function does what its name suggests: it creates a Vector of Vectors by sliding a window along a collection.  ","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"titles = map(bk -> bk.title, rl)\nslidingwindow(titles)","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"It can also work directly on a citable collection.","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"slidingwindow(rl)","category":"page"},{"location":"collections/#Recap:-citable-collections","page":"Citable collections","title":"Recap: citable collections","text":"","category":"section"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"On this page, we wrapped a citable collection type, te ReadingList around a Vector of CitableBooks.  We made the type identifiable as a citable collection.  We implemented filter of the collection on URN logic with the UrnComparisonTrait, and serialization with the CexSerializableTrait.  You can test these for these traits with boolean functions.","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"citablecollection(rl)","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"urncomparable(rl)","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"cexserializable(rl)","category":"page"},{"location":"collections/","page":"Citable collections","title":"Citable collections","text":"In addition, we made the ReadingList implement Julia's Iterators behavior.","category":"page"},{"location":"collections2/#Julia-collections","page":"Julia collections","title":"Julia collections","text":"","category":"section"},{"location":"collections2/","page":"Julia collections","title":"Julia collections","text":"By defining five functions on your citable collection, you can make them interoperate with dozens of generic Julia functions for working with collections of data.","category":"page"},{"location":"collections2/#What-you-need-to-define","page":"Julia collections","title":"What you need to define","text":"","category":"section"},{"location":"collections2/","page":"Julia collections","title":"Julia collections","text":"Thes are the five functions you want to define:","category":"page"},{"location":"collections2/","page":"Julia collections","title":"Julia collections","text":"using Base.Iterators\nimport Base: length\nimport Base: eltype\nimport Base: iterate\nimport Base: filter\nimport Base.Iterators: reverse","category":"page"},{"location":"collections2/","page":"Julia collections","title":"Julia collections","text":"In many cases, you can implement these functions with a single line of code.","category":"page"},{"location":"collections2/","page":"Julia collections","title":"Julia collections","text":"length: return the number of items in your collection\neltype: return the type of object your collection contains\niterate: you need to implement two required methods, one for an initial state and taking a single parameter for the collection, a second with two parameters, giving the collection and some state information.  If your collection is indexed (e.g., an Array type), your state information might simply be an index value.\nfilter: you can use collect to create an Array on your citable collection and filter the resulting Array.\nreverse: similarly, just collect the values of your collection and pass that to reverse","category":"page"},{"location":"collections2/#What-you-get","page":"Julia collections","title":"What you get","text":"","category":"section"},{"location":"collections2/","page":"Julia collections","title":"Julia collections","text":"Some of the functions this gives you are:","category":"page"},{"location":"collections2/","page":"Julia collections","title":"Julia collections","text":"functions returning iterators:","category":"page"},{"location":"collections2/","page":"Julia collections","title":"Julia collections","text":"collect\ndrop\ndropwhile\nenumerate\nflatten\npartition\nproduct\nrest\ntake\ntakewhile\nzip","category":"page"},{"location":"collections2/","page":"Julia collections","title":"Julia collections","text":"functions returning other kinds of value:","category":"page"},{"location":"collections2/","page":"Julia collections","title":"Julia collections","text":"accumulate\nall\nallunique\nany\nargmax\nargmin\ncollect\ncount\nextrema\nfirst\nin\nisempty\nmap\nreduce\nfoldl\nfoldr\nmaximum\nmap\nmapfoldl\nmapfoldr\nmapreduce\nminimum\nprod\nunique\n∌","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"using CitableBase\nstruct Isbn10Urn <: Urn\n    isbn::AbstractString\nend\n\nimport Base: show\nfunction show(io::IO, u::Isbn10Urn)\n    print(io, u.isbn)\nend\n\nstruct IsbnComparable <: UrnComparisonTrait end\nimport CitableBase: urncomparisontrait\nfunction urncomparisontrait(::Type{Isbn10Urn})\n    IsbnComparable()\nend\n\nimport CitableBase: urnequals\nfunction urnequals(u1::Isbn10Urn, u2::Isbn10Urn)\n    u1 == u2\nend\n\nimport CitableBase: urncontains\nfunction urncontains(u1::Isbn10Urn, u2::Isbn10Urn)\n    initial1 = components(u1.isbn)[3][1]\n    initial2 = components(u2.isbn)[3][1]\n    initial1 == initial2\nend\n\nfunction english(urn::Isbn10Urn)\n    langarea = components(urn.isbn)[3][1]\n    langarea == '0' || langarea == '1'\nend\n\nimport CitableBase: urnsimilar\nfunction urnsimilar(u1::Isbn10Urn, u2::Isbn10Urn)\n    initial1 = components(u1.isbn)[3][1]\n    initial2 = components(u2.isbn)[3][1]\n\n    (english(u1) && english(u2)) ||  initial1 == initial2\nend\n\n\n\ndistanthorizons = Isbn10Urn(\"urn:isbn10:022661283X\")\nenumerations = Isbn10Urn(\"urn:isbn10:022656875X\")\nqi = Isbn10Urn(\"urn:isbn10:3030234133\")\nwrong = Isbn10Urn(\"urn:isbn10:1108922036\")","category":"page"},{"location":"citable/#Citable-entities","page":"Citable objects","title":"Citable entities","text":"","category":"section"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"SummaryThe task: We will define a type representing a book identified by ISBN-10 number.  Our type will follow the CITE architecture's model of a citable object, so that we can identify it by URN and label, apply URN logic to compare objects of our new type, and serialize citable books to plain-text format.The implementation:define a new type of citable object, the CitableBook\nimplement citation functions for it (the CitableTrait)\nimplement comparison using URN logic (the UrnComparisonTrait)\nimplement round-trip serialization (the CexTrait)","category":"page"},{"location":"citable/#Defining-the-CitableBook","page":"Citable objects","title":"Defining the CitableBook","text":"","category":"section"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"We'll take advantage of Julia's type hierarchy to create an abstract CitablePublication type, and make CitableBook a subtype of it.  We won't create any further subtypes in this guide, but if we wanted to implement a type for some other form of citable publication, we could then share code applicable to any type of publication (that is, any subtype of CitablePublication).","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"We'll identify the book using the Isbn10Urn type we previously defined. Again, we'll keep the example simple, and just include strings for authors and a title.  You could elaborate this type however you choose.","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"abstract type CitablePublication <: Citable end\nstruct CitableBook <: CitablePublication\n    urn::Isbn10Urn\n    title::AbstractString\n    authors::AbstractString\nend","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"As we did with the Isbn10Urn, we'll override the Base package's show function for our new type.","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"function show(io::IO, book::CitableBook)\n    print(io, book.authors, \", *\", book.title, \"* (\", book.urn, \")\")\nend","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"We'll also override the == function so we can easily compare books for equality.","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"import Base.==\nfunction ==(book1::CitableBook, book2::CitableBook)\n    book1.urn == book2.urn && book1.title == book2.title && book1.authors == book2.authors\nend","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"We can test these by creating a couple of examples of our new type.","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"distantbook = CitableBook(distanthorizons, \"Distant Horizons: Digital Evidence and Literary Change\", \"Ted Underwood\")\nenumerationsbook = CitableBook(enumerations, \"Enumerations: Data and Literary Study\", \"Andrew Piper\")","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"distantbook == enumerationsbook","category":"page"},{"location":"citable/#Implementing-the-CitableTrait","page":"Citable objects","title":"Implementing the CitableTrait","text":"","category":"section"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"The first trait we will implement is the CitableTrait, which specifies that citable objects have an identifying URN and a human-readable label.  We'll follow the same general pattern we saw when we implemented the UrnComparisonTrait for the Isbn10Urn type, namely:","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"define a singleton type to use for the trait value\noverride the function identifying the trait value for our new type.  This time the function is named citabletrait, and we'll define it to return the concrete value CitableByIsnb10() for the type CitableBook.","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"struct CitableByIsbn10 <: CitableTrait end\n\nimport CitableBase: citabletrait\nfunction citabletrait(::Type{CitableBook})\n    CitableByIsbn10()\nend","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"citabletrait(typeof(distantbook))","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"CitableBase includes the citable function to test whether individual objects belong to a type implementing the function. (This is parallel to the urncomparable function we saw before.) ","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"citable(distantbook)","category":"page"},{"location":"citable/#Implementing-the-required-functions-urntype,-urn,-label","page":"Citable objects","title":"Implementing the required functions urntype, urn, label","text":"","category":"section"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"Implementing urntype, urn and label is now trivial.  The urntype function will report the type of URN we cite this object with. The urn function just returns the urn field of the book.  In Julia, Base.show underlies the string function, so since we have already implemented show for our book type, we can just return string(book) for the label function.","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"import CitableBase: urntype\nfunction urntype(book::CitableBook)\n    Isbn10Urn\nend\n\nimport CitableBase: urn\nfunction urn(book::CitableBook)\n    book.urn\nend\n\nimport CitableBase: label\nfunction label(book::CitableBook)\n    string(book)\nend","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"urntype(distantbook)","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"urn(distantbook)","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"label(distantbook)","category":"page"},{"location":"citable/#Implementing-the-UrnComparisonTrait","page":"Citable objects","title":"Implementing the UrnComparisonTrait","text":"","category":"section"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"We've already seen the UrnComparisonTrait.  We'll now define it for our book type in exactly the same way we did for our URN type. (We don't even need to re-import its functions.)","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"struct BookComparable <: UrnComparisonTrait end\n\nfunction urncomparisontrait(::Type{CitableBook})\n    BookComparable()\nend","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"urncomparisontrait(typeof(distantbook))","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"urncomparable(distantbook)","category":"page"},{"location":"citable/#Defining-the-required-functions-urnequals,-urncontains-and-urnsimilar","page":"Citable objects","title":"Defining the required functions urnequals, urncontains and urnsimilar","text":"","category":"section"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"Implementing the URN comparison functions for a pair of CitableBooks is nothing more than applying the same URN comparison to the books' URNs.","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"function urnequals(bk1::CitableBook, bk2::CitableBook)\n    bk1.urn == bk2.urn\nend\nfunction urncontains(bk1::CitableBook, bk2::CitableBook)\n    urncontains(bk1.urn, bk2.urn)\nend\nfunction urnsimilar(bk1::CitableBook, bk2::CitableBook)\n    urnsimilar(bk1.urn, bk2.urn)\nend","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"Let's test these functions on CitableBooks the same way we tested them for URNs.","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"dupebook = distantbook\nurnequals(distantbook, dupebook)","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"wrongbook = CitableBook(wrong, \"Andrew Piper\", \"Can We Be Wrong? The Problem of Textual Evidence in a Time of Data\")\nurnequals(distantbook, wrongbook)","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"As before, our URNs define \"similarity\" as belonging to the same language area, so Distant Horizons and Can We Be Wrong? are similar.","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"urnsimilar(distantbook, wrongbook)","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"But \"containment\" was defined as code for the same ISBN areas, so Distant Horizons does not \"contain\" Can We Be Wrong?.","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"urncontains(distantbook, wrongbook)","category":"page"},{"location":"citable/#Implementing-the-CexTrait","page":"Citable objects","title":"Implementing the CexTrait","text":"","category":"section"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"Finally, we will implement the CexTrait.  It requires that we be able to round trip citable content to a plain-text representation in CEX format, and instantiate an equivalent object from the generated CEX. Once again we will:","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"define a singleton type to use for the trait value\noverride the function identifying the trait value for our new type. This time the function is named cextrait, and we'll define it to return the concrete value CitableBook() for the type CitableBook.","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"struct BookCex <: CexTrait end\nimport CitableBase: cextrait\nfunction cextrait(::Type{CitableBook})  \n    BookCex()\nend","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"cextrait(typeof(distantbook))","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"CitableBase includes the cexserializable function to test individual objects.","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"cexserializable(distantbook)","category":"page"},{"location":"citable/#Defining-the-required-functions-cex-and-fromcex","page":"Citable objects","title":"Defining the required functions cex and fromcex","text":"","category":"section"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"The cex function composes a delimited-text representation of an object on a single line, with fields separated by an optionally specified delimiting string.","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"import CitableBase: cex\nfunction cex(book::CitableBook; delimiter = \"|\")\n    join([string(book.urn), book.title, book.authors], delimiter)\nend","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"cexoutput = cex(distantbook)","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"The inverse of cex is fromcex.  We need two essential pieces of information to convert a CEX string to an object:  the CEX source data, and the type of object to instantiate.  However, CitableBase dispatches this function on the trait value of the type want to instantiate.  Although we can find that value with the cextrait function, it needs to appear in the function signature for dispatch to work. We will therefore implement a function with three mandatory parameters: one for the trait value, and two more for the CEX data and Julia type to create.  (Two optional parameters allow you to define the delimiting string value, or create a dictionary with other configuration settings, but we won't need that for our implementation.)","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"import CitableBase: fromcex\nfunction fromcex(traitvalue::BookCex, cexsrc::AbstractString, T;      \n    delimiter = \"|\", configuration = nothing, strict = true)\n    fields = split(cexsrc, delimiter)\n    urn = Isbn10Urn(fields[1])\n    CitableBook(urn, fields[2], fields[3])\nend","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"tip: Example of configuring `fromcex`\nThe CitableLibrary package implements fromcex for its CiteLibrary class. It uses the configuration parameter to map different kinds of content to Julia classes, and create a library that many include many different kinds of citable collections.  See its documentation.","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"Note that because CitableBase can find our type's trait value on its own, it can delegate to the function we just wrote even when you invoke it only two parameters:  all a user needs to specify is the CEX data and Julia type.","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"restored = fromcex(cexoutput, CitableBook)","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"The acid test: did we wind up with an equivalent book?","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"distantbook == restored","category":"page"},{"location":"citable/#Recap:-citable-objects","page":"Citable objects","title":"Recap: citable objects","text":"","category":"section"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"This page  first defined the CitableBook.  Here's what an example looks like:","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"dump(distantbook)","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"We implemented three traits which you can test for with boolean functions.","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"citable(distantbook)","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"urncomparable(distantbook)","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"cexserializable(distantbook)","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"Those three traits allowed us to identify books by URN, compare books by URN, and round-trip books to and from plain-text representation.","category":"page"},{"location":"citable/","page":"Citable objects","title":"Citable objects","text":"Our initial goal was to manage a reading list of books citable by ISBN number.  We could do that directly with, say, a Vector of CitableBooks, but the next page shows how we could go a step futher by wrapping a Vector of CitableBooks in a type supporting the CITE architecture's definition of a collection with citable content.","category":"page"},{"location":"#CitableBase","page":"Home","title":"CitableBase","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package defines traits and abstract types for the essential concepts of the CITE architecture. ","category":"page"},{"location":"#Essential-concepts","page":"Home","title":"Essential concepts","text":"","category":"section"},{"location":"#Behaviors-of-citable-resources","page":"Home","title":"Behaviors of citable resources","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The CITE architecture can be described by four kinds of behavior, corresponding in Julia to four traits or interfaces.","category":"page"},{"location":"","page":"Home","title":"Home","text":"identification.  Scholarly resources are identified using the syntax of the IETF URN specification, and have a human-readable label.  This is expressed by implementing the CitableTrait.\ncomparison.  Citable resources can be compared using the URN logic of equality, containment and  similarity.  This is expressed by implementing the  UrnComparisonTrait.\nserialization.  Citable resources can be losslessly serialized to plain-text representation in CEX format and instantiated from the same plain-text representation.  This is expressed by implementing the CexTrait.\niteration. Collections of citable content can be processed sequentially. This is expressed by implementing the iterators interface from Julia's Iterators module.","category":"page"},{"location":"#Abstractions-of-essential-types","page":"Home","title":"Abstractions of essential types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Using these building blocks, the CitableBase further defines three core abstractions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"an identifier uniquely identifies scholarly resources using the syntax of the IETF URN specification. This is represented by the Urn abstract type, and requires implementing the UrnComparisonTrait.\na citable entity is a discrete object identified by a URN.  This is represented by the Citable abstract type, and requires implementing the CitableTrait, UrnComparisonTrait, and CexTrait.\na citable collection is a collection of content identifiable by URN.  Unlike identifiers and citable entities, they do not fall within a single type hierarchy, and are not represented by subtyping an abstract type.  Instead, they are identified by the CitableCollectionTrait, and implement the UrnComparisonTrait, CexTrait and Iterators.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"tip: An illustration: the CitableCorpus package\nSome citable collections might additionally implement the CitableTrait, in effect making them simultaneously a discrete citable obect (the collection as a whole), and a collection with citable content.  The CitableCorpus package illustrates these distinctions handily.  Its CitablePassage is a citable object representing a single passage of text.  The CitableDocument is both a citable object with its own URN and label, and a collection of citable passages.  The CitableCorpus is a pure citable collection of citable documents and citable passages, but does not have its own distinct identifier and label: it is purely a container type.","category":"page"},{"location":"#Contents-of-this-user's-guide","page":"Home","title":"Contents of this user's guide","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It is perfectly possible to use packages implementing the abstractions of CitableBase without understanding how CitableBase is designed.  This user's guide is for anyone who needs to build their own custom implementations or simply wishes to understand how these abstractions can be implemented.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The guide works through a hypothetical example to design a reading list of books citable by URN values.  The guide first illustrates how to implement a custom URN type for ISBN-10 numbers. It then creates a custom citable object for books cited by ISBN-10 numbers, and finally defines a custom citable collection representing a reading list.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Following the user's guide, the documentation includes the formal API documentation for the exported functions and types of the CitableBase package.","category":"page"}]
}

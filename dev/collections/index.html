<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Citable collections · CitableBase.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CitableBase.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../urns/">Identifiers</a></li><li><a class="tocitem" href="../citable/">Citable objects</a></li><li class="is-active"><a class="tocitem" href>Citable collections</a><ul class="internal"><li><a class="tocitem" href="#Defining-the-ReadingList"><span>Defining the <code>ReadingList</code></span></a></li><li><a class="tocitem" href="#Implementing-the-CitableCollectionTrait"><span>Implementing the <code>CitableCollectionTrait</code></span></a></li><li><a class="tocitem" href="#Implementing-the-UrnComparisonTrait"><span>Implementing the <code>UrnComparisonTrait</code></span></a></li><li><a class="tocitem" href="#Implementing-the-CexTrait"><span>Implementing the <code>CexTrait</code></span></a></li><li><a class="tocitem" href="#Implementing-required-and-optional-frnctions-from-Base.Iterators"><span>Implementing required and optional frnctions from <code>Base.Iterators</code></span></a></li><li><a class="tocitem" href="#More-free-stuff!"><span>More free stuff!</span></a></li><li><a class="tocitem" href="#Recap:-citable-collections"><span>Recap: citable collections</span></a></li></ul></li><li><a class="tocitem" href="../collections2/">Julia collections</a></li><li><a class="tocitem" href="../apis/">API documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Citable collections</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Citable collections</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/cite-architecture/CitableBase.jl/blob/main/docs/src/collections.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Citable-collections"><a class="docs-heading-anchor" href="#Citable-collections">Citable collections</a><a id="Citable-collections-1"></a><a class="docs-heading-anchor-permalink" href="#Citable-collections" title="Permalink"></a></h1><blockquote><h2>Summary</h2><p><strong>The task</strong>: We want to create a type for working with a <em>collection</em> of the citable books we developed on the previous page.   We should be able to filter the collection by appying URN logic to the identifiers for our books.  We should be able to write our collection to plain-text format and re-instantiate it from the plain-text representation.  And we should be able to apply any Julia functions for working with iterable content to our book list.</p><p><strong>The implementation</strong>:</p><ul><li>define a new type for a collection of citable books, the <code>ReadingList</code> type</li><li>identify it as a citable collection (the <code>CitableCollectionTrait</code>)</li><li>implement filtering the collection using URN logic (the <code>UrnComparisonTrait</code>)</li><li>implement round-trip serialization (the <code>CexTrait</code>)</li><li>make the collection available to all Julia functions working with iterable content (<code>Iterators</code>)</li></ul></blockquote><h2 id="Defining-the-ReadingList"><a class="docs-heading-anchor" href="#Defining-the-ReadingList">Defining the <code>ReadingList</code></a><a id="Defining-the-ReadingList-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-ReadingList" title="Permalink"></a></h2><p>Our model for a reading list is simple: it&#39;s just a Vector of citable publications.  We&#39;ll annotate our vector as containing subtypes of the abstract <code>CitablePublication</code> we previously defined, even though in this example we&#39;ll only use our one concrete implementation, the <code>CitableBook</code>.  As with our other custom types, we&#39;ll override <code>Base.show</code>.</p><pre><code class="language-julia hljs">struct ReadingList
    publications::Vector{&lt;: CitablePublication}
end</code></pre><pre><code class="language-julia hljs">function show(io::IO, readingList::ReadingList)
    print(io, &quot;ReadingList with &quot;, length(readingList.publications), &quot; items&quot;)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">show (generic function with 305 methods)</code></pre><p>Let&#39;s see an example.</p><pre><code class="language-julia hljs">books = [distantbook, enumerationsbook, wrongbook, qibook]
rl = ReadingList(books)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ReadingList with 4 items</code></pre><p>The <code>publications</code> field is just a normal Julia Vector.</p><pre><code class="language-julia hljs">rl.publications[4]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Christopher W. Forstall and Walter J. Scheirer, *Quantitative Intertextuality: Analyzing the Markers of Information Reuse* (urn:isbn10:3030234133)</code></pre><p>What will make it different from other Vectors is that it will support a series of CITE traits</p><h2 id="Implementing-the-CitableCollectionTrait"><a class="docs-heading-anchor" href="#Implementing-the-CitableCollectionTrait">Implementing the <code>CitableCollectionTrait</code></a><a id="Implementing-the-CitableCollectionTrait-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-the-CitableCollectionTrait" title="Permalink"></a></h2><p>We first want to identify our new type as fufilling the requirements of a citable collection with the <code>CitableCollectionTrait</code>. We&#39;ll repeat the pattern:</p><ol><li>define a singleton type for the trait value.</li><li>override the function identifying the trait value for our new type.  Here the function is named <code>citablecollectiontrait</code>, and we&#39;ll define it to return the concrete value <code>CitableReadingList</code> for the tyupe <code>ReadingList</code>.</li></ol><pre><code class="language-julia hljs">struct CitableReadingList &lt;: CitableCollectionTrait end

import CitableBase: citablecollectiontrait
function citablecollectiontrait(::Type{ReadingList})
    CitableReadingList()
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">citablecollectiontrait (generic function with 2 methods)</code></pre><pre><code class="language-julia hljs">citablecollectiontrait(typeof(rl))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.CitableReadingList()</code></pre><p>Use the <code>citablecollection</code> function to test if a specific object is a citable collection.</p><pre><code class="language-julia hljs">citablecollection(rl)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Like citable objects, citable collections should report the type of URN they use for citation.</p><pre><code class="language-julia hljs">import CitableBase: urntype
function urntype(readingList::ReadingList)
    Isbn10Urn
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">urntype (generic function with 4 methods)</code></pre><pre><code class="language-julia hljs">urntype(rl)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.Isbn10Urn</code></pre><p>The promise we now need to fulfill is that our collection will implement three further traits for URN comparison, serialization and iteration.</p><h2 id="Implementing-the-UrnComparisonTrait"><a class="docs-heading-anchor" href="#Implementing-the-UrnComparisonTrait">Implementing the <code>UrnComparisonTrait</code></a><a id="Implementing-the-UrnComparisonTrait-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-the-UrnComparisonTrait" title="Permalink"></a></h2><p>We have previously implemented the <code>UrnComparisonTrait</code> for an identifer type (the <code>Isbn10Urn</code>) and for a citable object type (the <code>CitableBook</code>).  In both of those cases, we compared two objects of the same type, and returned a boolean result of comparing them on URN logic.  </p><p>For our citable collection, we will implement the same suite of functions, but with a different signature and result type.  This time, our first parameter will be a URN which we will use to <em>filter</em> the collection given in the second parameter.  The result will be a (possibly empty) list of content in our citable collection – in this example, a list of <code>CitableBook</code>s.</p><p>We mark our <code>ReadingList</code> type as urn-comparable exactly as we did for <code>Isbn10Urn</code>s and <code>CitableBook</code>s.</p><pre><code class="language-julia hljs">struct ReadingListComparable &lt;: UrnComparisonTrait end
function urncomparisontrait(::Type{ReadingList})
    ReadingListComparable()
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">urncomparisontrait (generic function with 6 methods)</code></pre><pre><code class="language-julia hljs">urncomparable(rl)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><h3 id="Implementing-the-required-functions-urnequals,-urncontains-and-urnsimilar"><a class="docs-heading-anchor" href="#Implementing-the-required-functions-urnequals,-urncontains-and-urnsimilar">Implementing the required functions <code>urnequals</code>, <code>urncontains</code> and <code>urnsimilar</code></a><a id="Implementing-the-required-functions-urnequals,-urncontains-and-urnsimilar-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-the-required-functions-urnequals,-urncontains-and-urnsimilar" title="Permalink"></a></h3><p>To implement the required functions, we&#39;ll just lean on the work we&#39;ve already done: we&#39;ll use the boolean version of those functions to filter our collections.</p><pre><code class="language-julia hljs">function urnequals(urn::Isbn10Urn, reading::ReadingList, )
    filter(item -&gt; urnequals(item.urn, urn), reading.publications)
end

function urncontains(urn::Isbn10Urn, reading::ReadingList)
    filter(item -&gt; urncontains(item.urn, urn), reading.publications)
end

function urnsimilar(urn::Isbn10Urn, reading::ReadingList)
    filter(item -&gt; urnsimilar(item.urn, urn), reading.publications)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">urnsimilar (generic function with 6 methods)</code></pre><p>If your collection does not allow duplicate identifiers, <code>urnequals</code> should return a list of 0 or 1 item.</p><pre><code class="language-julia hljs">urnequals(distanthorizons, rl)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Main.CitableBook}:
 Ted Underwood, *Distant Horizons: Digital Evidence and Literary Change* (urn:isbn10:022661283X)</code></pre><p>Three of the books in our list are published in the English-language zone, and therefore will satisfy <code>urnsimilar</code> when compared to <em>Distant Horizons</em>.</p><pre><code class="language-julia hljs">urnsimilar(distanthorizons, rl)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Main.CitableBook}:
 Ted Underwood, *Distant Horizons: Digital Evidence and Literary Change* (urn:isbn10:022661283X)
 Andrew Piper, *Enumerations: Data and Literary Study* (urn:isbn10:022656875X)
 Andrew Piper, *Can We Be Wrong? The Problem of Textual Evidence in a Time of Data* (urn:isbn10:1108922036)</code></pre><p>But only two are published in the same ISBN area code as <em>Distant Horizons</em>:</p><pre><code class="language-julia hljs">urncontains(distanthorizons, rl)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Main.CitableBook}:
 Ted Underwood, *Distant Horizons: Digital Evidence and Literary Change* (urn:isbn10:022661283X)
 Andrew Piper, *Enumerations: Data and Literary Study* (urn:isbn10:022656875X)</code></pre><h2 id="Implementing-the-CexTrait"><a class="docs-heading-anchor" href="#Implementing-the-CexTrait">Implementing the <code>CexTrait</code></a><a id="Implementing-the-CexTrait-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-the-CexTrait" title="Permalink"></a></h2><p>As we did with citable objects, we want to ensure that we can round-trip an entire collection to and from delimited-text format.  We&#39;ll make our new <code>ReadingList</code> type implement <code>CexTrait</code> in the same way as <code>CitableBook</code>.</p><pre><code class="language-julia hljs">struct ReadingListCex &lt;: CexTrait end
function cextrait(::Type{ReadingList})
    ReadingListCex()
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">cextrait (generic function with 5 methods)</code></pre><pre><code class="language-julia hljs">cexserializable(rl)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><h3 id="Implementing-the-required-functions-cex-and-fromcex"><a class="docs-heading-anchor" href="#Implementing-the-required-functions-cex-and-fromcex">Implementing the required functions <code>cex</code> and <code>fromcex</code></a><a id="Implementing-the-required-functions-cex-and-fromcex-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-the-required-functions-cex-and-fromcex" title="Permalink"></a></h3><p>We will serialize our collection with a header line identifying it as <code>citecollection</code> block, followed by one line for each book in our list.  We can format the books&#39; data by mapping each book to an invocation the <code>cex</code> that we previously wrote for <code>CitableBook</code>s.</p><pre><code class="language-julia hljs">function cex(reading::ReadingList; delimiter = &quot;|&quot;)
    header = &quot;#!citecollection\n&quot;
    strings = map(ref -&gt; cex(ref, delimiter=delimiter), reading.publications)
    header * join(strings, &quot;\n&quot;)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">cex (generic function with 5 methods)</code></pre><pre><code class="language-julia hljs">cexoutput = cex(rl)
println(cexoutput)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">#!citecollection
urn:isbn10:022661283X|Distant Horizons: Digital Evidence and Literary Change|Ted Underwood
urn:isbn10:022656875X|Enumerations: Data and Literary Study|Andrew Piper
urn:isbn10:1108922036|Can We Be Wrong? The Problem of Textual Evidence in a Time of Data|Andrew Piper
urn:isbn10:3030234133|Quantitative Intertextuality: Analyzing the Markers of Information Reuse|Christopher W. Forstall and Walter J. Scheirer</code></pre><p>Recall from our experience implementing CEX serialization for <code>CitableBook</code>s that we will need to expose three mandatory parameters for <code>fromcex</code>: the trait value, the CEX data and the Julia type we want to instantiate.</p><pre><code class="language-julia hljs">function fromcex(trait::ReadingListCex, cexsrc::AbstractString, T;
    delimiter = &quot;|&quot;, configuration = nothing, strict = true)

    lines = split(cexsrc, &quot;\n&quot;)
    datalines = filter(ln -&gt; !isempty(ln), lines)
    isbns = CitableBook[]
    inblock = false
    for ln in datalines
        if ln == &quot;#!citecollection&quot;
            inblock = true
        elseif inblock
            bk = fromcex(ln, CitableBook)
            push!(isbns, bk)
        end
    end
    ReadingList(isbns)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">fromcex (generic function with 9 methods)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>To keep this example brief and avoid introducing other packages, our implementation of <code>fromcex</code> naively assumes <code>cexsrc</code> will contain a single CEX block introduced by the <code>#!citecollection</code> heading.  This would break on real world CEX data sources: in a real application, we would instead use the <code>CiteEXchange</code> package to parse and extract appropriate blocks.  See the <a href="https://cite-architecture.github.io/CiteEXchange.jl/stable/">documentation of <code>CiteEXchange</code></a>, or look at how a package like <a href="https://cite-architecture.github.io/CitableCorpus.jl/stable/"><code>CitableCorpus</code></a> uses <code>CiteEXchange</code> in its implementation of <code>fromcex</code> for different data type.</p></div></div><p>Once again, we can now invoke <code>fromcex</code> with just the parameters for the CEX data and desired Julia type to create, and <code>CitableBase</code> will find our implementation.</p><pre><code class="language-julia hljs">fromcex(cexoutput, ReadingList)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ReadingList with 4 items</code></pre><h3 id="Free-bonus!"><a class="docs-heading-anchor" href="#Free-bonus!">Free bonus!</a><a id="Free-bonus!-1"></a><a class="docs-heading-anchor-permalink" href="#Free-bonus!" title="Permalink"></a></h3><p><code>CitableBase</code> optionally allows you to include a third parameter to the <code>fromcex</code> function naming the type of reader to apply to the first string parameter.  Valid values are <code>StringReader</code>, <code>FileReader</code> or <code>UrlReader</code>.  The previous example relied on the default value of <code>StringReader</code>.  The following examples use the file <code>RL/test/data/dataset.cex</code>  in this repository; its contents are the output of <code>cex(rl)</code> above.</p><pre><code class="language-julia hljs">fname = joinpath(root, &quot;RL&quot;, &quot;test&quot;, &quot;data&quot;, &quot;dataset.cex&quot;)
fileRL = fromcex(fname, ReadingList, FileReader)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ReadingList with 4 items</code></pre><pre><code class="language-julia hljs">url = &quot;https://raw.githubusercontent.com/cite-architecture/CitableBase.jl/dev/RL/test/data/dataset.cex&quot;
urlRL = fromcex(url, ReadingList, UrlReader)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ReadingList with 4 items</code></pre><h2 id="Implementing-required-and-optional-frnctions-from-Base.Iterators"><a class="docs-heading-anchor" href="#Implementing-required-and-optional-frnctions-from-Base.Iterators">Implementing required and optional frnctions from <code>Base.Iterators</code></a><a id="Implementing-required-and-optional-frnctions-from-Base.Iterators-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-required-and-optional-frnctions-from-Base.Iterators" title="Permalink"></a></h2><p>The <code>Iterators</code> module in Julia <code>Base</code> was one of the first traits or interfaces in Julia.  It allows you to apply the same functions to many types of iterable collections.  We need to import the <code>Base.iterate</code> function, and implement two versions of it for our new type: one with a single parameter for the collection, and one with a second parameter maintaining some kind of state information.  Both of them have the same return type: either <code>nothing</code>, or a Tuple pairing one item in the collection with state information.</p><p>Since our reading list is keeping books in a Vector internally, we can use the state parameter to pass along an index into the Vector.  In the version of <code>iterate</code> with no parameters, we&#39;ll return the first item in the list, and set the &quot;state&quot; value to 2.  In the two-parameter version, we&#39;ll return the item indexed by the state count, and bump the count up one.</p><pre><code class="language-julia hljs">import Base: iterate

function iterate(rlist::ReadingList)
    isempty(rlist.publications) ? nothing : (rlist.publications[1], 2)
end

function iterate(rlist::ReadingList, state)
    state &gt; length(rlist.publications) ? nothing : (rlist.publications[state], state + 1)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">iterate (generic function with 234 methods)</code></pre><p>It is also useful (and trivial) to implement the optional methods for the length and base type of the collection.</p><pre><code class="language-julia hljs">import Base: length
function length(readingList::ReadingList)
    length(readingList.publications)
end


import Base: eltype
function eltype(readingList::ReadingList)
    CitablePublication
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">eltype (generic function with 70 methods)</code></pre><pre><code class="language-julia hljs">length(rl)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4</code></pre><pre><code class="language-julia hljs">eltype(rl)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.CitablePublication</code></pre><p>Now our <code>ReadingList</code> type is usable with all the richness of <a href="https://docs.julialang.org/en/v1/base/collections/#lib-collections-iteration">the Julia interface for iterators</a>.  Just a few examples:</p><ul><li><code>for</code> loops </li></ul><pre><code class="language-julia hljs">for item in rl
    println(item)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Ted Underwood, *Distant Horizons: Digital Evidence and Literary Change* (urn:isbn10:022661283X)
Andrew Piper, *Enumerations: Data and Literary Study* (urn:isbn10:022656875X)
Andrew Piper, *Can We Be Wrong? The Problem of Textual Evidence in a Time of Data* (urn:isbn10:1108922036)
Christopher W. Forstall and Walter J. Scheirer, *Quantitative Intertextuality: Analyzing the Markers of Information Reuse* (urn:isbn10:3030234133)</code></pre><ul><li>checking for presence of an item</li></ul><pre><code class="language-julia hljs">distantbook in rl</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><ul><li>collect contents without having to know anything about the internal structure of the type</li></ul><pre><code class="language-julia hljs">collect(rl)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Main.CitablePublication}:
 Ted Underwood, *Distant Horizons: Digital Evidence and Literary Change* (urn:isbn10:022661283X)
 Andrew Piper, *Enumerations: Data and Literary Study* (urn:isbn10:022656875X)
 Andrew Piper, *Can We Be Wrong? The Problem of Textual Evidence in a Time of Data* (urn:isbn10:1108922036)
 Christopher W. Forstall and Walter J. Scheirer, *Quantitative Intertextuality: Analyzing the Markers of Information Reuse* (urn:isbn10:3030234133)</code></pre><h2 id="More-free-stuff!"><a class="docs-heading-anchor" href="#More-free-stuff!">More free stuff!</a><a id="More-free-stuff!-1"></a><a class="docs-heading-anchor-permalink" href="#More-free-stuff!" title="Permalink"></a></h2><p>The <code>slidingwindow</code> function does what its name suggests: it creates a Vector of Vectors by sliding a window along a collection.  </p><pre><code class="language-julia hljs">titles = map(bk -&gt; bk.title, rl)
slidingwindow(titles)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{SubArray{String, 1, Vector{String}, Tuple{UnitRange{Int64}}, true}}:
 [&quot;Distant Horizons: Digital Evidence and Literary Change&quot;, &quot;Enumerations: Data and Literary Study&quot;]
 [&quot;Enumerations: Data and Literary Study&quot;, &quot;Can We Be Wrong? The Problem of Textual Evidence in a Time of Data&quot;]
 [&quot;Can We Be Wrong? The Problem of Textual Evidence in a Time of Data&quot;, &quot;Quantitative Intertextuality: Analyzing the Markers of Information Reuse&quot;]</code></pre><p>It can also work directly on a citable collection.</p><pre><code class="language-julia hljs">slidingwindow(rl)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{SubArray{Main.CitablePublication, 1, Vector{Main.CitablePublication}, Tuple{UnitRange{Int64}}, true}}:
 [Ted Underwood, *Distant Horizons: Digital Evidence and Literary Change* (urn:isbn10:022661283X), Andrew Piper, *Enumerations: Data and Literary Study* (urn:isbn10:022656875X)]
 [Andrew Piper, *Enumerations: Data and Literary Study* (urn:isbn10:022656875X), Andrew Piper, *Can We Be Wrong? The Problem of Textual Evidence in a Time of Data* (urn:isbn10:1108922036)]
 [Andrew Piper, *Can We Be Wrong? The Problem of Textual Evidence in a Time of Data* (urn:isbn10:1108922036), Christopher W. Forstall and Walter J. Scheirer, *Quantitative Intertextuality: Analyzing the Markers of Information Reuse* (urn:isbn10:3030234133)]</code></pre><p>The <code>partitionvect</code> function partitions a Vector into a series of Vectors of a given size.  In contrast to <code>slidingwindow</code>, the elements in the new Vectors do not overlap.</p><p><code>partitionvect</code> can work on any generic Vector.</p><pre><code class="language-julia hljs">v = collect(1:10)
partitionvect(v)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{SubArray{Int64, 1, Vector{Int64}, Tuple{UnitRange{Int64}}, true}}:
 [1, 2]
 [3, 4]
 [5, 6]
 [7, 8]
 [9, 10]</code></pre><p>It also works on any citable collection.</p><pre><code class="language-julia hljs">partitionvect(rl)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{SubArray{Main.CitablePublication, 1, Vector{Main.CitablePublication}, Tuple{UnitRange{Int64}}, true}}:
 [Ted Underwood, *Distant Horizons: Digital Evidence and Literary Change* (urn:isbn10:022661283X), Andrew Piper, *Enumerations: Data and Literary Study* (urn:isbn10:022656875X)]
 [Andrew Piper, *Can We Be Wrong? The Problem of Textual Evidence in a Time of Data* (urn:isbn10:1108922036), Christopher W. Forstall and Walter J. Scheirer, *Quantitative Intertextuality: Analyzing the Markers of Information Reuse* (urn:isbn10:3030234133)]</code></pre><h2 id="Recap:-citable-collections"><a class="docs-heading-anchor" href="#Recap:-citable-collections">Recap: citable collections</a><a id="Recap:-citable-collections-1"></a><a class="docs-heading-anchor-permalink" href="#Recap:-citable-collections" title="Permalink"></a></h2><p>On this page, we wrapped a citable collection type, te <code>ReadingList</code> around a Vector of <code>CitableBook</code>s.  We made the type identifiable as a citable collection.  We implemented filter of the collection on URN logic with the <code>UrnComparisonTrait</code>, and serialization with the <code>CexSerializableTrait</code>.  You can test these for these traits with boolean functions.</p><pre><code class="language-julia hljs">citablecollection(rl)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><pre><code class="language-julia hljs">urncomparable(rl)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><pre><code class="language-julia hljs">cexserializable(rl)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>In addition, we made the <code>ReadingList</code> implement Julia&#39;s <code>Iterators</code> behavior.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../citable/">« Citable objects</a><a class="docs-footer-nextpage" href="../collections2/">Julia collections »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Thursday 22 September 2022 15:21">Thursday 22 September 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
